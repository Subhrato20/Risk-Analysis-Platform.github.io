# -*- coding: utf-8 -*-
"""WeightsRun.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u8ybDJ3iPA7IdRD5AJ9iSugh4bmCblX-
"""

import torch
import torch.nn as nn
import pandas as pd
from joblib import load
import numpy as np
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder

# Definition of the Autoencoder class
class Autoencoder(nn.Module):
    def __init__(self, num_features):
        super(Autoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(num_features, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 16),  # Encoded representation
            nn.ReLU()
        )
        self.decoder = nn.Sequential(
            nn.Linear(16, 32),
            nn.ReLU(),
            nn.Linear(32, 64),
            nn.ReLU(),
            nn.Linear(64, num_features),  # Output size same as input size
            nn.Sigmoid()  # Use sigmoid if the input is normalized between 0 and 1
        )

    def forward(self, x):
        encoded = self.encoder(x)
        decoded = self.decoder(encoded)
        return encoded, decoded

# Definition of the RegressionNet class
class RegressionNet(nn.Module):
    def __init__(self):
        super(RegressionNet, self).__init__()
        self.fc1 = nn.Linear(16, 64)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(64, 1)  # Predicting a single value

    def forward(self, x):
        x = self.relu(self.fc1(x))
        return self.fc2(x)

# Function to load models
def load_models():
    num_features = 59  # Adjust this to match the original model's feature size
    autoencoder = Autoencoder(num_features)
    regression_model = RegressionNet()

    autoencoder.load_state_dict(torch.load('autoencoder_weights.pth'))
    regression_model.load_state_dict(torch.load('regression_model_weights.pth'))
    return autoencoder, regression_model

# Function to predict damage
def predict_damage(input_data):
    autoencoder, regression_model = load_models()
    preprocessor = load('preprocessor.joblib')

    df = pd.DataFrame([input_data])
    X = preprocessor.transform(df).toarray()  # Using the same preprocessor as during training
    X_tensor = torch.tensor(X.astype(np.float32))  # Convert to tensor

    autoencoder.eval()
    regression_model.eval()
    with torch.no_grad():
        encoded_features, _ = autoencoder(X_tensor)
        predicted_damage = regression_model(encoded_features)

    if predicted_damage.item() < 0:
        return int(-predicted_damage.item() * 1e7)
    return int(predicted_damage.item() * 1e7)

# Example usage
if __name__ == "__main__":
    input_features = {
        'Start Year': 2024,
        'Disaster Subtype': 'Earthquake',
        'Location': 'New York'
    }
    predicted_damage = predict_damage(input_features)
    print(f"Predicted Total Damage: {predicted_damage} 'US$")

